<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="canonical" href="https://geekworksresearch.com/Pages/Devlog1">
    <meta name="description" content="In this devlog, I will be explaining the fundamentals of, and some of my experiences from developing, V-Slicing, a brand-new slicing method built on simple ideas. Designed to overcome the limitations of current methods. I also showcase a test print sliced with one of the development versions. We will look at the limitations of this basic implementation of the method.">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GeekWorks Devlog 1: Beyond geometrical shapes</title>
    <link rel="stylesheet" href="devlog.css">
    <link rel="icon" type="image/x-icon" href="../GeekWorksLogo.png">
</head>
<body>
    <div id="BannerImage"><img src="../Images/Devlog1/Banner.png">
<h1>Beyond geometrical shapes</h1></div>
    <div id="TextArea"><h4>A New Approach</h4><p>One tried-and-true method for tackling complex problems is discretizing them. When summoning forth the exact layer shape from the enigmatic and arcane realm of mathematics isn't possible, we have to simplify the problem. For example, figuring out where to place cones in conical slicing or finding areas with support similar to arc overhangs is tough. But if we turn the mesh into voxels, we can easily calculate each layer based on the previous ones. This way we can create layers with varying thickness and slope. These offer many advantages over planar layers. This is the fundamental idea behind V-slicing.</p><p>Voxels are the cells of a 3D grid. This means that they can technically be any shape. In our case voxels won't be perfect cubes, this lets us change the resolution in each axis separately. Allowing for more detail if needed in specific directions.</p><h4>From Mesh to Gcode</h4><p>To convert a mesh to Gcode we have to refine it through several steps. <br> A basic V-slicer has 6 steps:<br>1. We load the model and apply any changes we want to the mesh. This includes scaling and rotating it as needed.<br>2. We generate our grid of voxels from the mesh. <br>3. We can create the layers using a breadth-first search where each shell will become a layer. <br>4. We cut out the infill pattern to reduce material usage. In some cases, infill could be left out completely. However, this can introduce some unprintable areas. As such it will be addressed after the first iterations are complete.<br>5. Toolpath generation, where we take our voxels and find the fastest way to print all of them. Here we have to use the least direction changes and unnecessary travel moves to increase print speeds.<br>6. We convert back from voxel coordinates to physical size. Then we convert the toolpath Gcode. While doing so we apply any material flow adjustments and export the result.</p><img src="../Images/Devlog1/VSliceProcess.png" class = "fullWidthImage"></img>
<p>These are the steps of a simple V-Slicer however, simple won't cut it. In the simplest V-Slicer for example, the resolution is directly linked to nozzle size. This means that prints come out very blocky. Furthermore, slope angle either can't be limited or doing so causes layers to be split into many separate lines. Which leads to reduced print quality and structural strength. On top of that, the solution to both problems comes with noticeable increases to runtime. We will need to solve all of those issues if we want to match or surpass the quality of Cura.</p><h4>Early results</h4><p>While developing V-Slicing, I created two test versions to find potential issues. These versions had basic UIs to aid debugging. One was written for Unity, which was a short-lived proof of concept. The other version was closer to an alpha build written in C# for WPF. I would like to go over the results of the latter. The lessons learned in that version will form the foundations of Crystalite development.</p><p><img src="../Images/Devlog1/Benchy.png"style="float:left;"></img>
This is the test file used to evaluate quality and reliability. It is a modified Benchy that was given a stand so it is suspended in mid-air to test supportless capabilities. Do also note that the text from the bottom was removed for early slicer limitations. However, the latest test version could handle them properly. All test prints were printed on a mostly stock Ender3, with the only mods being a 0.6mm nozzle and bed leveling probe.  This was the first successful full-scale benchy I managed to print after 6 months of development. This version's biggest problem was that the resolution was directly linked to nozzle size and layer thickness was also linked to voxel size. This meant a relatively small maximum layer height to reduce the maximum slope. I sliced this model with a 0.8mm nozzle setting to increase print speed. This resulted in a layer height of 0.175mm but lesser quality on overhangs since arc overhang style overhangs line width must match nozzle diameter.</p><p><img src="../Images/Devlog1/BenchyVoxelization.png"style="float:right;"></img>
Because the resolution here was 0.8mm, the voxelization artifacts are easily visible on curved areas. A unique quirk of this version was that it had stair stepping like artifact on xy but not z like most slicers do due to relatively low resolution in xy compared to z. This will have to be eliminated in Crystalite by decoupling resolution from nozzle size. This wasn't done in early builds since it required a much more complex toolpath generation algorithm. On the other hand, increasing resolution will increase slicing time which will have to be reduced. The most obvious way to do so is to use the GPU via OpenCL. We can't use CUDA since that is NVIDIA-specific and we want it to be able to work on both Intel, AMD, and integrated graphics too. This leaves only OpenCL for our compute framework.</p><p><img src="../Images/Devlog1/OverhangSurface.png"style="float:left;"></img>
When I first examined the print I was delighted with the quality of the horizontal overhang. This overhang method should only work when the line width matches the nozzle size. Considering this the result for a 0.8mm line width on a 0.6mm nozzle, it is quite clean. This shows that V-Slicing successfully integrates the strengths of conical slicers and arc overhangs while negating their weaknesses. We can also see how the layer's shape changes to best fit the model. This however can cause issues. The text for example had to be removed in this version because it would result in areas that tried to print below already printed areas. This was fixed when I changed the layer generation logic, and so it won't be a problem in Crystalite. This fix also allows layers to become thicker when that is possible without causing a collision. This also has the unexpected side effect of eliminating stair stepping almost completely on any printed layer thickness given a high enough z resolution.</p><p>Since I made that test print, I have added multiple upgrades to the test build. However, I realized that the fundamentals needed to change so much that I chose to do a complete rewrite. This is due to many reasons. In the first two versions, infill was added during voxelization. This however also meant that some areas that had support printed as if they were overhangs resulting in worse print quality and reduced print speeds. For this reason, infill was moved to after layer generation which isn't possible in the test version cleanly. The way voxels are stored needs to change as well. The test version uses hash sets which isn't a bad option, but if we want to use the GPU we need to replace it with arrays. This means that a rewrite is necessary.<br>I tested greedy layers, which is a method meant to increase layer thickness by printing a benchy. During this test print there was an off-by-one error somewhere in the code leading to major over-extrusion and an unusable part. However greedy layers did provide the expected result of much faster print times with heavily reduced stair stepping where visible from the ~30-40% over extrusion. At this point, I already decided on a complete rewrite so I didn't bother finding the error. As such I am not planning on releasing this test build. Instead, I will focus on Crystalite development and releasing a polished, safe-to-use slicer.</p><h4>Going forward</h4><p>I will try to get devlogs out as often as possible, but given that each focuses on a stage of the slicer, release intervals may vary. As such I decided to create a <a href="https://discord.gg/86WPpAwg" target="_blank" rel="noopener noreferrer">Discord</a> server where I will post a notification when a new devlog is out. It's also a place where you can share your thoughts about the project. And if you would like to support development I have also set up a <a target="_blank" rel="noopener noreferrer" href="https://patreon.com/GeekWorks?utm_medium=unknown&utm_source=join_link&utm_campaign=creatorshare_creator&utm_content=copyLink">Patreon</a> page where I will be posting a few behind-the-scenes photos and updates.</p><p>In the next devlog, I will be starting work on the actual code for Crystalite. That devlog will be about code structure, mesh import, and voxelization. Development will have two phases, the first one will be getting the algorithms to work together and creating the UI for it. The second phase will focus on migrating the code from the CPU to the GPU to decrease slicing time.</p></div>
    <div id="NavigationBar"><div style="cursor: pointer;" class="leftNav" onclick="window.location = 'Devlog0'" class="DevlogLinkLeft">Previous devlog</div>
<div style="cursor: pointer;" class="centerNav" onclick="window.location = '../'" class="DevlogLinkMainMenu">Home Page </div>
<div class="sideNav"></div>


    </div>
    <script src="../scripts/devlog.js"></script>
</body>
</html>
