{"HighlightImageNames":["Images/Devlog1/Devlog1Banner.png"],"Projects":[{"Devlogs":[{"Paragraphs":[{"Id":0,"Type":"h4","ImageSide":0,"ImageName":"","Text":"Is There More to Discover?"},{"Id":1,"Type":"p","ImageSide":0,"ImageName":null,"Text":"It's easy to think that slicers are starting to reach their limits. We are seemingly approaching a point where the limiting factor is our hardware. This may be true when it comes to speed but not quality. We still have to deal with the rough underside of overhangs and stair-stepping. But are we sure that this is how far can we push our printers? Have we ventured far enough from the norm of planar slicing to see whether we are actually at the summit? Have we dared to backtrack far enough to realize we took the wrong turn? I think not!"},{"Id":2,"Type":"h4","ImageSide":0,"ImageName":null,"Text":"Novel Slicing Strategies"},{"Id":3,"Type":"p","ImageSide":3,"ImageName":"Images/Devlog0/ConicalVsPlanar.png","Text":""},{"Id":4,"Type":"p","ImageSide":1,"ImageName":"Images/Devlog0/singleConeConical.webp","Text":"Our first stop in our journey takes us to <a href=\"https://www.mdpi.com/2076-3417/11/18/8760\" target=\"_blank\" rel=\"noopener noreferrer\">conical slicing</a>. A method that is very similar to traditional slicing techniques. The only difference is that it uses a cone instead of a plane. Which enables the printing of horizontal overhangs. Although it can help with overhangs it doesn't eliminate the underlying issue. It instead shifts our overhang capabilities in one direction. As such masking the problem without truly addressing it."},{"Id":5,"Type":"p","ImageSide":2,"ImageName":"Images/Devlog0/multiConeConical.webp","Text":"To address this directionality we could fit cones to every overhang. This however complicates the slicing algorithms used. Or the user could assign them manually but this would heavily reduce usability. The next major issue this method has is printer compatibility. It was meant for use with 4-axis printers, where the hotend can rotate around the cone's center. This allows for improved clearance compared to 3-axis printers."},{"Id":6,"Type":"p","ImageSide":0,"ImageName":null,"Text":"Reducing the cone's slope can improve the required clearance. This inevitably compromises overhang capability, as the two are directly linked. As a result, this method may excel on more complex printers. But my goal is good compatibility with current I3-style printers. To attain supportless slicing we will need to venture further from the norm."},{"Id":7,"Type":"h4","ImageSide":0,"ImageName":null,"Text":"Wait So You DON'T Need Overlap?"},{"Id":8,"Type":"p","ImageSide":0,"ImageName":null,"Text":"The previously mentioned methods used the overlap with the previous layer to act as support to the overhang... but is the issue the lack of overlap or the geometry of the layer? Turns out it may be the latter. This method ventured far from the norm. It attaches plastic to the side of already printed areas. With <a href=\"https://github.com/stmcculloch/arc-overhang\" target=\"_blank\" rel=\"noopener noreferrer\">arc overhangs</a>, we can print horizontal overhangs in any direction on any printer."},{"Id":9,"Type":"p","ImageSide":1,"ImageName":"/Images/Devlog0/arcPattern.webp","Text":"They did this by printing the first layer of an overhang in small circular sections. The sections are filled in a way that the plastic always has something to stick to. This method has some minor flaws, but it also highlights the potential of our printers. However the center of the circles tends to droop down due to excess heating. Another issue is warping. Arc overhangs tend to warp as new layers are printed on top of them. This warping happens because the layers are too thin to support themselves. When the next layer starts shrinking due to cooling, they can easily warp. This can be fixed by adding small supports in the corners of the layer to keep them in place during cooling. But this does add back some extra material. While it's a good approach and should be added to most slicers. For my goals, this isn't good enough."},{"Id":10,"Type":"h4","ImageSide":0,"ImageName":null,"Text":"A completely different approach"},{"Id":11,"Type":"p","ImageSide":0,"ImageName":null,"Text":"If neither method gives us what we want we will just have to look even further from the norm. Which means ditching geometric shapes as the foundation for our layers. This is where, a method I've been experimenting with over the past year comes in, V-slicing. This method manages to incorporate the advantages of arc overhangs and conical slicing. It does this while countering their drawbacks. Granted it has its unique problems which I will have to address. The goal is to develop a slicer that is simple to use while reducing wasted material. This method can potentially print over 90° on a stock Ender 3. This is just theoretical at this point but overhangs up to 90° have already been tested. while also managing to reduce stair stepping if not eliminate it in most cases. This, however, as with everything, comes at a cost. The algorithms used are logically simple but computationally complex."},{"Id":12,"Type":null,"ImageSide":0,"ImageName":null,"Text":"In devlog 1, I showcase my results so far. I also explain some of the underlying algorithms I've used so far. I will elaborate on these when we get to their devlogs, as each devlog will explore the algorithms for each layer. My primary goal by doing this is improving 3D printing which is why, as I write a V-Slicing-based slicer called Crystalite, I will also elaborate on all the potential issues I encountered. During these devlogs my ultimate goal is print quality on par with or surpassing Cura. I hope you will join me in that process through future devlogs."}],"Id":0,"Title":"Journey To Slicing's Bleeding Edge","HighlightImageName":"Images/Devlog0/Devlog0Thumbnail.png","BannerImageName":"Images/Devlog0/Devlog0Banner.png","ShortDescription":"Join me at the forefront of 3D printing innovation. In this introductory devlog, we'll explore groundbreaking slicing techniques that challenge the status quo. From conical slicing to arc overhangs, we'll examine these alternative approaches their limitations, and advantages that form the foundation for V-Slicing."},{"Paragraphs":[{"Id":0,"Type":"h4","ImageSide":0,"ImageName":null,"Text":"A New Approach"},{"Id":1,"Type":"p","ImageSide":0,"ImageName":null,"Text":"One tried-and-true method for tackling complex problems is discretizing them. When summoning forth the exact layer shape from the enigmatic and arcane realm of mathematics isn't possible, we have to simplify the problem. For example, figuring out where to place cones in conical slicing or finding areas with support similar to arc overhangs is tough. But if we turn the mesh into voxels, we can easily calculate each layer based on the previous ones. This way we can create layers with varying thickness and slope. These offer many advantages over planar layers. This is the fundamental idea behind V-slicing."},{"Id":3,"Type":"p","ImageSide":0,"ImageName":null,"Text":"Voxels are the cells of a 3D grid. This means that they can technically be any shape. In our case voxels won't be perfect cubes, this lets us change the resolution in each axis separately. Allowing for more detail if needed in specific directions."},{"Id":4,"Type":"h4","ImageSide":0,"ImageName":null,"Text":"From Mesh to Gcode"},{"Id":5,"Type":"p","ImageSide":0,"ImageName":"","Text":"To convert a mesh to Gcode we have to refine it through several steps. <br> A basic V-slicer has 6 steps:<br>1. We load the model and apply any changes we want to the mesh. This includes scaling and rotating it as needed.<br>2. We generate our grid of voxels from the mesh. <br>3. We can create the layers using a breadth-first search where each shell will become a layer. <br>4. We cut out the infill pattern to reduce material usage. In some cases, infill could be left out completely. However, this can introduce some unprintable areas. As such it will be addressed after the first iterations are complete.<br>5. Toolpath generation, where we take our voxels and find the fastest way to print all of them. Here we have to use the least direction changes and unnecessary travel moves to increase print speeds.<br>6. We convert back from voxel coordinates to physical size. Then we convert the toolpath Gcode. While doing so we apply any material flow adjustments and export the result."},{"Id":6,"Type":"","ImageSide":3,"ImageName":"Images/Devlog1/VSliceProcess.png","Text":""},{"Id":8,"Type":"p","ImageSide":0,"ImageName":null,"Text":"These are the steps of a simple V-Slicer however, simple won't cut it. In the simplest V-Slicer for example, the resolution is directly linked to nozzle size. This means that prints come out very blocky. Furthermore, slope angle either can't be limited or doing so causes layers to be split into many separate lines. Which leads to reduced print quality and structural strength. On top of that, the solution to both problems comes with noticeable increases to runtime. We will need to solve all of those issues if we want to match or surpass the quality of Cura."},{"Id":9,"Type":"h4","ImageSide":0,"ImageName":"","Text":"Early results"},{"Id":10,"Type":"p","ImageSide":0,"ImageName":null,"Text":"While developing V-Slicing, I created two test versions to find potential issues. These versions had basic UIs to aid debugging. One was written for Unity, which was a short-lived proof of concept. The other version was closer to an alpha build written in C# for WPF. I would like to go over the results of the latter. The lessons learned in that version will form the foundations of Crystalite development."},{"Id":11,"Type":"p","ImageSide":1,"ImageName":"/Images/Devlog1/Benchy.png","Text":"This is the test file used to evaluate quality and reliability. It is a modified Benchy that was given a stand so it is suspended in mid-air to test supportless capabilities. Do also note that the text from the bottom was removed for early slicer limitations. However, the latest test version could handle them properly. All test prints were printed on a mostly stock Ender3, with the only mods being a 0.6mm nozzle and bed leveling probe.  This was the first successful full-scale benchy I managed to print after 6 months of development. This version's biggest problem was that the resolution was directly linked to nozzle size and layer thickness was also linked to voxel size. This meant a relatively small maximum layer height to reduce the maximum slope. I sliced this model with a 0.8mm nozzle setting to increase print speed. This resulted in a layer height of 0.175mm but lesser quality on overhangs since arc overhang style overhangs line width must match nozzle diameter."},{"Id":12,"Type":"p","ImageSide":2,"ImageName":"/Images/Devlog1/BenchyVoxelization.png","Text":"Because the resolution here was 0.8mm, the voxelization artifacts are easily visible on curved areas. A unique quirk of this version was that it had stair stepping like artifact on xy but not z like most slicers do due to relatively low resolution in xy compared to z. This will have to be eliminated in Crystalite by decoupling resolution from nozzle size. This wasn't done in early builds since it required a much more complex toolpath generation algorithm. On the other hand, increasing resolution will increase slicing time which will have to be reduced. The most obvious way to do so is to use the GPU via OpenCL. We can't use CUDA since that is NVIDIA-specific and we want it to be able to work on both Intel, AMD, and integrated graphics too. This leaves only OpenCL for our compute framework."},{"Id":13,"Type":"p","ImageSide":1,"ImageName":"/Images/Devlog1/OverhangSurface.png","Text":"When I first examined the print I was delighted with the quality of the horizontal overhang. This overhang method should only work when the line width matches the nozzle size. Considering this the result for a 0.8mm line width on a 0.6mm nozzle, it is quite clean. This shows that V-Slicing successfully integrates the strengths of conical slicers and arc overhangs while negating their weaknesses. We can also see how the layer's shape changes to best fit the model. This however can cause issues. The text for example had to be removed in this version because it would result in areas that tried to print below already printed areas. This was fixed when I changed the layer generation logic, and so it won't be a problem in Crystalite. This fix also allows layers to become thicker when that is possible without causing a collision. This also has the unexpected side effect of eliminating stair stepping almost completely on any printed layer thickness given a high enough z resolution."},{"Id":14,"Type":null,"ImageSide":0,"ImageName":null,"Text":"Since I made that test print, I have added multiple upgrades to the test build. However, I realized that the fundamentals needed to change so much that I chose to do a complete rewrite. This is due to many reasons. In the first two versions, infill was added during voxelization. This however also meant that some areas that had support printed as if they were overhangs resulting in worse print quality and reduced print speeds. For this reason, infill was moved to after layer generation which isn't possible in the test version cleanly. The way voxels are stored needs to change as well. The test version uses hash sets which isn't a bad option, but if we want to use the GPU we need to replace it with arrays. This means that a rewrite is necessary.<br>I tested greedy layers, which is a method meant to increase layer thickness by printing a benchy. During this test print there was an off-by-one error somewhere in the code leading to major over-extrusion and an unusable part. However greedy layers did provide the expected result of much faster print times with heavily reduced stair stepping where visible from the ~30-40% over extrusion. At this point, I already decided on a complete rewrite so I didn't bother finding the error. As such I am not planning on releasing this test build. Instead, I will focus on Crystalite development and releasing a polished, safe-to-use slicer."},{"Id":15,"Type":"h4","ImageSide":0,"ImageName":null,"Text":"Going forward"},{"Id":16,"Type":"p","ImageSide":0,"ImageName":null,"Text":"I will try to get devlogs out as often as possible, but given that each focuses on a stage of the slicer, release intervals may vary. As such I decided to create a <a href=\"https://discord.gg/86WPpAwg\" target=\"_blank\" rel=\"noopener noreferrer\">Discord</a> server where I will post a notification when a new devlog is out. It's also a place where you can share your thoughts about the project. And if you would like to support development I have also set up a <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://patreon.com/GeekWorks?utm_medium=unknown&utm_source=join_link&utm_campaign=creatorshare_creator&utm_content=copyLink\">Patreon</a> page where I will be posting a few behind-the-scenes photos and updates."},{"Id":17,"Type":null,"ImageSide":0,"ImageName":null,"Text":"In the next devlog, I will be starting work on the actual code for Crystalite. That devlog will be about code structure, mesh import, and voxelization. Development will have two phases, the first one will be getting the algorithms to work together and creating the UI for it. The second phase will focus on migrating the code from the CPU to the GPU to decrease slicing time."}],"Id":1,"Title":"Beyond geometrical shapes","HighlightImageName":"Images/Devlog1/Devlog1Thumbnail.png","BannerImageName":"Images/Devlog1/Devlog1Banner.png","ShortDescription":"In this devlog, I will be explaining the fundamentals of, and some of my experiences from developing, V-Slicing, a brand-new slicing method built on simple ideas. Designed to overcome the limitations of current methods. I also showcase a test print sliced with one of the development versions. We will look at the limitations of this basic implementation of the method."}],"Title":"Crystalite","HighlightImageName":"Images/Devlog0/Devlog0Thumbnail.png","ShortDescription":"Crystalite is a work-in-progress V-slicing based slicer that aims to compete with mainstream slicers in terms of usability and quality."}]}